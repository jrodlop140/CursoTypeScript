{"version":3,"file":"bundle.js","mappings":";;;;;;;;;;AAAa;AACb;AACA,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACA,uDAAuD;AACvD;AACA;AACA;AACA,0MAA0M,cAAc;AACxN,8BAA8B,sBAAsB;AACpD,0BAA0B,YAAY,sBAAsB,qCAAqC,2CAA2C,MAAM;AAClJ,4BAA4B,MAAM,iBAAiB,YAAY;AAC/D,uBAAuB;AACvB,8BAA8B;AAC9B,6BAA6B;AAC7B,4BAA4B;AAC5B;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B,oBAAoB,EAAE,WAAW,EAAE;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,wCAAwC;AAC5E;AACA;AACA,eAAe,WAAW,MAAM,WAAW;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,kCAAkC;AACnC;AACA;AACA;AACA,eAAe;AACf;AACA;AACA,cAAc;AACd,kBAAkB;AAClB;AACA;AACA;AACA;AACA,+CAA+C,eAAe,yCAAyC,eAAe;AACtH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,MAAM,IAAI,aAAa;AAC9E;AACA,oBAAoB,8BAA8B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,OAAO;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,OAAO;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,OAAO;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO,GAAG,KAAK;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,QAAQ,EAAE,UAAU;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,8BAA8B,cAAc,iBAAiB,cAAc,sBAAsB,iBAAiB;AACnJ;AACA,kCAAkC,eAAe,OAAO,GAAG,aAAa;AACxE;AACA;AACA;AACA;AACA;AACA,2CAA2C,eAAe,OAAO,GAAG,aAAa,KAAK;AACtF;AACA;AACA,yCAAyC,eAAe,aAAa,KAAK;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA,yBAAyB,gDAAgD;AACzE;AACA,mBAAmB,+CAA+C;AAClE;;AAEA;AACA,+BAA+B,EAAE;AACjC;;AAEA;;AAEA;AACA,mBAAmB,MAAM;AACzB,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,gBAAgB;AAC5C;AACA;AACA;AACA,KAAK;AACL;AACA,6BAA6B,+CAA+C,KAAK,KAAK;AACtF;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,GAAG;AAClC;AACA;AACA;AACA;AACA,4BAA4B,sBAAsB;AAClD;AACA;AACA,KAAK;AACL;AACA;AACA,4BAA4B,aAAa,OAAO,kDAAkD;AAClG;AACA,yBAAyB,OAAO;AAChC;AACA,6BAA6B,SAAS;AACtC;AACA;AACA,6BAA6B,KAAK;AAClC;AACA;AACA;;;;;;;;UE3VA;UACA;UACA;UACA;UACA","sources":["webpack://cursotypescript/./src/index.ts","webpack://cursotypescript/webpack/before-startup","webpack://cursotypescript/webpack/startup","webpack://cursotypescript/webpack/after-startup"],"sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __await = (this && this.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }\nvar __asyncGenerator = (this && this.__asyncGenerator) || function (thisArg, _arguments, generator) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\n    return i = Object.create((typeof AsyncIterator === \"function\" ? AsyncIterator : Object).prototype), verb(\"next\"), verb(\"throw\"), verb(\"return\", awaitReturn), i[Symbol.asyncIterator] = function () { return this; }, i;\n    function awaitReturn(f) { return function (v) { return Promise.resolve(v).then(f, reject); }; }\n    function verb(n, f) { if (g[n]) { i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; if (f) i[n] = f(i[n]); } }\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\n    function fulfill(value) { resume(\"next\", value); }\n    function reject(value) { resume(\"throw\", value); }\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconsole.log(\"Hola Mundo\");\n/**\n * Tipos de datos:\n *\n * string\n * number - enteros y decimales\n * boolean - true / false\n * null\n * undefined\n */\nvar var1 = true;\nvar var2 = \"Hola\";\nvar nombre = \"Julio\"; //Variable global\nlet apellido = \"Rodríguez\"; //Variable local\nlet a = \"Pepe\", b = \"Paco\", c = 45;\nconst PI = 3.1415;\nconsole.log(\"Hola \" + \"Mundo\");\nconsole.log(nombre + \" \" + apellido);\nconsole.log(nombre, apellido);\nconsole.log(`Hola ${nombre}`);\nconsole.log(`Hola ${a}`, \"y\", `${b}`);\n//Declaración de arrays\nlet alumnos1A = [\"Juan\", \"Jose\", \"Alex\"];\nlet alumnos2A = [\"Fran\"];\n//Forma de propagar arrays\nlet alumnos = [...alumnos1A, ...alumnos2A, \"Pablo\"];\n//Array con diferentes datos\nlet datos = [\"Hola\", 2, true];\nconsole.log(alumnos);\n//Como se declaran objetos en TypeScript\nlet misDatos = {\n    nombre: \"Jose\",\n    apellidos: \"Rodriguez\",\n    edad: 18\n};\nlet configuracion = Object.assign({ versionTS: \"ES6\", versioncodigo: \"1.0\" }, misDatos);\nlet propiedad1 = configuracion.versionTS;\nlet propiedad2 = configuracion.versioncodigo;\nconsole.log(`${propiedad1}`, `${propiedad2}`);\n//Declaración de enumeraciones\n//Le damos un valor a las claves para que salgan los valores por consola sino salen números\nvar estadoTarea;\n(function (estadoTarea) {\n    estadoTarea[\"Pendiente\"] = \"P\";\n    estadoTarea[\"En proceso\"] = \"E\";\n    estadoTarea[\"Terminado\"] = \"T\";\n})(estadoTarea || (estadoTarea = {}));\n;\nlet estadoPendiente = estadoTarea[\"Pendiente\"];\nconsole.log(estadoPendiente);\nlet tarea1 = { nombre: \"tarea1\", prioridad: 2, estado: estadoTarea[\"En proceso\"] };\n//Variable con dos tipos\nlet empleado2;\nempleado2 = { nombre: \"Paco\", edad: 38, sueldo: 3600, codigoIdentificativo: \"2345\" };\nlet empleado1 = { nombre: \"Pepe\", edad: 28, sueldo: 1300 };\nconsole.log(empleado1.nombre);\nconsole.log(empleado2.codigoIdentificativo);\n//Operador Ternario\n//condicion ? verdadero : falso\nconsole.log(tarea1.estado == \"E\" ? `La tarea ${tarea1.nombre} se encuentra en ejecución` : `La tarea ${tarea1.nombre} no se encuentra en ejecución`);\n//IF-ELSE\nif (tarea1.estado == \"E\") {\n    //Codigo C1\n}\nelse if (tarea1.estado == \"P\") {\n    //Codigo C2\n}\nelse {\n    //Codigo C3\n}\n//SWITCH\nswitch (tarea1.estado) {\n    case \"E\":\n        console.log(\"Tarea en proceso\");\n        break;\n    default:\n        console.log(\"No tiene estado\");\n        break;\n}\n//Try-Catch\ntry {\n    let numero1 = 1;\n    console.log(numero1.toString());\n}\ncatch (error) {\n    console.log(\"Se ha producido un error al convertir un numero a String\", error);\n}\n//Bucles\nlet listadeTareas = [\n    {\n        nombre: \"Tarea 1\",\n        prioridad: 2,\n        estado: estadoTarea[\"En proceso\"]\n    },\n    {\n        nombre: \"Tarea 2\",\n        prioridad: 0,\n        estado: estadoTarea.Pendiente\n    },\n    {\n        nombre: \"Tarea 3\",\n        prioridad: 15,\n        estado: estadoTarea.Terminado\n    }\n];\n//Bucle for each\nlistadeTareas.forEach((tarea, index) => console.log(`${index}- ${tarea.nombre}`));\n//Bucle for \nfor (let index = 0; index < listadeTareas.length; index++) {\n    const tarea = listadeTareas[index];\n    console.log(tarea);\n}\n//Bucle while\nwhile (tarea1.estado !== estadoTarea.Terminado) {\n    if (tarea1.prioridad == 20) {\n        estadoTarea.Terminado;\n        break;\n    }\n    else {\n        tarea1.prioridad++;\n    }\n}\n//Bucle do-while\ndo {\n    tarea1.prioridad++;\n    tarea1.estado = estadoTarea.Terminado;\n} while (tarea1.estado != estadoTarea.Terminado);\n//Funciones\n/**\n * Función que muestra un saludo por consola\n */\nfunction saludar() {\n    let nombre = \"Julio\";\n    console.log(\"Hola Mundo\", `${nombre}`);\n}\n//Llamada de la función saludar\nsaludar();\n//Función clásica con parámetros\n/**\n * Función que saluda a una persona\n * @param nombre Nombre de la persona a saludar\n */\nfunction saludar2(nombre) {\n    console.log(\"Hola Mundo\", `${nombre}`);\n}\nsaludar2(nombre);\n//Función con parámetros por defecto\n/**\n * Función que saluda a una person\n * @param nombre Nombre de la persona a saludar que es por defecto Pepe\n */\nfunction saludarPorDefecto(nombre = \"Pepe\") {\n    console.log(\"Hola Mundo\", `${nombre}`);\n}\nsaludarPorDefecto();\n//Función con parámetros opcionales \n/**\n * Función que saluda a alguien si se le pasa por parámetro el nombre y sino saluda a anónimo\n * @param nombre Nombre de la persona a saludar\n */\nfunction saludarOPCIONAL(nombre) {\n    if (nombre) {\n        console.log(\"Hola Mundo: \" + nombre);\n    }\n    else {\n        console.log(\"Hola anónimo\");\n    }\n}\nsaludarOPCIONAL();\nsaludarOPCIONAL(nombre);\n//Función con parámetros de varios tipos\nfunction funcionVariosParametros(nombre, edad) {\n    console.log(`${nombre},${edad}`);\n}\nlet edad = 25;\nfuncionVariosParametros(nombre, edad);\n//Función con un parámetro que puede ser de varios tipos\nfunction parametroDistintoTipo(a) {\n    if (typeof (a) == 'string') {\n        console.log(\"La variable a es un string\");\n    }\n    else {\n        console.log(\"La variable a es un número\");\n    }\n}\nparametroDistintoTipo(nombre);\nparametroDistintoTipo(edad);\n//Funciones con return\nfunction ejemploReturn(nombre, apellidos) {\n    return `${nombre} ${apellidos}`;\n}\nconsole.log(ejemploReturn(\"Pepe\", \"Viyuela\"));\n//Función que puede recibir un número indeterminado de argumentos\nfunction multipleParams(...nombres) {\n    nombres.forEach(nombre => {\n        console.log(nombre);\n    });\n}\nmultipleParams(\"Pepe\", \"Paco\", \"Pedro\");\n//Función anónima\nlet fanonima = function () { console.log(\"Hola Mundo\"); };\nfanonima();\n//A este tipo de funciones también se le puede pasar una lista\nlet listaNombres = [\"Juan\", \"Jose\"];\nmultipleParams(...listaNombres);\n//Funciones arrow\n/**\n * Las funciones arrow son una sintaxis compacta de definir funciones en JavaScript y TypeScript.\n * Proporcionan una forma más breve y clara de escribir funciones en comparación con la sintaxis tradicional,\n * lo que mejora la legibilidad y mantiene la seguridad de los tipos.\n *\n * (param1, param2, ..., paramN) => {}\n */\nlet getDatosTarea = (tarea) => { return `La tarea denominada ${tarea.nombre} cuyo estado es ${tarea.estado} tiene una prioridad ${tarea.prioridad} `; };\nconsole.log(getDatosTarea(tarea1));\nlet farrow = (tarea, indice) => { console.log(`${indice}-${tarea.nombre}`); };\n//Le pasamos al forEach una función arrow ya definida\nconsole.log(\"For each con función arrow ya definida\");\nlistadeTareas.forEach(farrow);\n//Le pasamos al forEach una función arrow directamente\nconsole.log(\"For each con función arrow definida dentro del forEach\");\nlistadeTareas.forEach((tarea, indice) => { console.log(`${indice}-${tarea.nombre}`); });\n//Le pasamos al forEach una función anónima\nconsole.log(\"For each con función anónima dentro del forEach\");\nlistadeTareas.forEach(function (tarea) { console.log(`${tarea.nombre}`); });\n/**\n * Funciones CallBack\n * Una función callback es una función que se pasa a otra función como parámetro y dentro de la misma es llamada.\n * Hay que tener en cuenta que una función se trata como un objeto.\n */\n//Ejemplo 1: \nconst funcionMuestra = function () {\n    console.log(\"CallBack desde función estándar\");\n};\nsetTimeout(funcionMuestra, 100); // La función timeout llama a funciónMuestra después de 100ms\n// Ejemplo 2: paso de una función anónima\nsetTimeout(function () { console.log(\"CallBack desde función anónima\"); }, 1000);\n// Ejemplo 3: paso de una función flecha\nsetTimeout(() => { console.log(\"CallBack desde función flecha\"); }, 500);\n/* // Ejemplo 4:\n\nlet muestraDatos = function (a:string, b:number, c:string[]){\n    console.log(`Ejemplo 4 - ${a}`);\n}\n\nlistadeTareas.forEach(muestraDatos)\n\nlistadeTareas.forEach((valor:string,indice:number,datos:string[]) => {\n    console.log(`${valor}, mostrado desde función CallBack fecha`)\n}) */\n// Ejemplo 5: \nlet fsuma = function suma(a, b) {\n    console.log(\"Llamada desde función opera\");\n    return a + b;\n};\nlet fresta = function resta(a, b) {\n    return a - b;\n};\n// En este ejemplo estamos definiendo que la función opera espera recibir como parámetro una función CallBack\n// Concretamente, estamos diciendo que la función como entrada tiene que tener dos parámetros y devolver un número\n// Cuando se llama a dicha función CallBack desde la función principal se le pasan dichos parámetros y se vuelve a operar con el resultado\nfunction opera(x, y, callbackfuntion) {\n    return callbackfuntion(x, y);\n}\nopera(2, 3, fsuma);\nopera(2, 3, fresta);\n//Funciones asincronas\nfunction asincrona() {\n    return __awaiter(this, void 0, void 0, function* () {\n        let suma = 0;\n        for (let index = 0; index < 100000; index++) {\n            suma += index;\n        }\n        return suma;\n    });\n}\nasincrona().then((data) => { console.log(`El resultado de ejecutar asyc = ${data}`); });\nconsole.log(\"Línea de código posterior a la función asincrona\");\nfunction getDataUniversity() {\n    return __awaiter(this, void 0, void 0, function* () {\n        const data = yield fetch(\"http://universities.hipolabs.com/search?country=Spain\");\n        let respuesta = yield data.json();\n        return respuesta;\n    });\n}\ngetDataUniversity().then((data) => {\n    data.forEach((universidad) => console.log(universidad.name));\n});\n//funciones generadoras\nfunction* fgeneradora() {\n    for (let tarea in listadeTareas) {\n        yield listadeTareas[tarea];\n    }\n}\nlet funciongen = fgeneradora;\n//ASYNC GENERADORA\nfunction* fgeneradora2() {\n    yield \"Hola\";\n    yield \"Mundo\";\n    yield \"IES\";\n}\nlet llamadafgen2 = fgeneradora2();\nlet str = llamadafgen2.next(); //{value:\"Hola\",done:false}\nfunction obtenerDatosWeb() {\n    return __asyncGenerator(this, arguments, function* obtenerDatosWeb_1() {\n        let peticion = yield __await(fetch(\"https://haveibeenpwned.com/api/v2/breaches\"));\n        let datos = yield __await(peticion.json());\n        for (let index = 0; index < datos.length; index++) {\n            yield yield __await(datos[index]);\n        }\n    });\n}\nlet datosWebPage = obtenerDatosWeb();\ndatosWebPage.next().then(({ value, done }) => { console.log(value.Name, \"-\", value.Description); });\nfunction saludarSobrecarga(nombre, apellido, edad) {\n    let saludo = `Hola ${nombre}`;\n    if (apellido != undefined) {\n        saludo = saludo + `${apellido}`;\n    }\n    if (edad != undefined) {\n        saludo = saludo + `${edad}`;\n    }\n    return saludo;\n}\n","","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = {};\n__webpack_modules__[\"./src/index.ts\"](0, __webpack_exports__);\n",""],"names":[],"sourceRoot":""}